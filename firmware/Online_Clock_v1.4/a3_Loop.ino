//********** ВЫПОЛНЯЕТСЯ ЦИКЛИЧНО **********//


void loop() {
  crm.run();  // Обслуживание системных функций библиотеки "CRMui"

  GetTimeDate();  // Функция синхронизации времени и даты


  if (ntp.getYear() == 1970) {   // Если синхронизация с NTP не прошла после включения часов (до синхронизации год в библиотеке NTP установлен на 1970)
    if (FlagEfReqTmp == true) {  // Выполняем предварительный запрос температуры и анимацию 1 раз
      sensor.requestTemp();      // Предварительный запрос температуры
      Ef_After_On();             // Пока ждём получение температуры показывем анимацию с мигающим символом "-" на всех сигментах
      FlagEfReqTmp = false;      // Опускаем флаг одноразового выполнения анимации с предварительным запросом температуры
    }
    TempToArray(I_tempC);  // Выводим температуру на часы примерно на 10 сек (пока ESP8266 не подкл. к WiFi и NTP не обновит данные). Это то, что нужно по времени отображения температуры после Вкл.

  } else if (FlagShowTemp == true) {  // Иначе, если флаг показа температуры с кнопки на часах поднят, то...
    FastLED.clear();                  // Очищаем ленту
    TempToArray(I_tempC);             // Выводим температуру на часы

    if (millis() - tmrShTmp > SHOW_TEMP) {  // Сравниваем, если время с последнего обновления (из вызванной функции "ShowTemp()") прошло больше, чем указанно в "SHOW_TEMP", то...
      tmrShTmp = millis();                  // Ещё раз обновляем время в таймере
      FlagShowTemp = false;                 // Опускаем флаг показа температуры
    }

  } else {                   // Иначе постоянно выводим часы
    FastLED.clear();         // Очищаем ленту
    TimeToArray(GetTime());  // Иначе выводим время на часы
  }



  //Проверка, какой из режимов регулировки яркости включён
  switch (Regim_bright) {
    case 1:                   // Если вкл. первый режим, то выполняем...
      AutoBrightnessCheck();  // Функцию Авторегулировки яркости по датчику освещённости
      break;                  // Выходим из case

    case 2:                       // Если вкл. второй режим, то выполняем...
      ManualBrightnessSetting();  // Функцию Ручная регулировка яркости
      break;                      // Выходим из case

    case 3:                          // Если вкл. третий режим, то выполняем...
      ScheduledBrightnessControl();  // Функцию Регулировка яркости по расписанию
      break;                         // Выходим из case
  }



  //Проверка виртуальных кнопок на нажатие (кнопки на WEB интерфейсе)
  if (crm.btnSwStatus()) {  // Проверка конкретных кнопок на нажатие
    // crm.btnCallback("[ID кнопки]", [Функция для выполнения]);
    crm.btnCallback("ForceUpdNTP", ForceupdateNTP);                                  // Виртуальная кнопка "ForceUpdNTP" для принудительного обновления времени с NTP
    crm.btnCallback("reboot", Reboot);                                               // Виртуальная кнопка "reboot" для применения настроек и перезагрузки ESP8266
    if (Flag_Each_Sigment == true) crm.btnCallback("RndBtn", Random_Color_Segment);  // Если флаг ПОДНЯТ, то выполняем функцию генерации и установки рандомного цвета для каждого сегмента
    if (Flag_Each_Sigment == false) crm.btnCallback("RndBtn", Random_Color);         // А если ОПУЩЕН, то выполняем функцию генерации и установки рандомного цвета для всех сегментов
  }

  // Проверка аппаратных кнопок на нажатие (кнопки на часах)
  // crm.btnCallback("[пин подключения кнопки]", [Функция для выполнения], [уровень при нажатии]);
  crm.btnCallback(BUT_SET, ShowTemp, LOW);   // Кнопка SET
  crm.btnCallback(BUT_UP, UpEf, LOW);        // Кнопка UP
  crm.btnCallback(BUT_DOWN, DnEf, LOW);      // Кнопка DOWN
  crm.btnCallback(BUT_RESET, ResButt, LOW);  // Кнопка RESET


  //Проверка ежечасного сигнала
  if (Flag_Sig == true) {  // Если флаг подачи ежечасного сигнала поднят, то...
    Hourly_Signal();       // Выполняем функцию
  }





  //Проверка, какой из режимов отображения цветов включён
  switch (Regim_Color) {
    case 1:          // Если вкл. первый режим, то выполняем...
      Your_Color();  // Функцию установки своего произвольного цвета с WEB интерфейса
      break;         // Выходим из case

    case 2:  // Если вкл. второй режим, то проверяем другие условия
      //Поднимаем флаг для генерации рандомного цвета 1 раз каждую последнюю секунду (проверка миллисекунд нужна, так как программа успевает выполнить за 1 секунду много раз функцию со сменой флагов)
      if (second == 59 && ntp.getMs() >= 996) FlagEfRand_Min = true;  // Если настало 59 секунд и больше или равна 996 миллисекунд, то поднимаем флаг (точное значение 999 не указываю, так как программа бывает не успевает проверить условие за 1 мс)

      if (FlagEfRand_Min == true && Flag_Each_Sigment == false) {  // И если поднят флаг генерации рандомного цвета (1 раз каждую минуту) и опущен флаг разноцветных сегментов и точек, то...
        Random_Color();                                            // Выполняем функцию рандомной генерации и установки цвета на всех сегментах
        FlagEfRand_Min = false;                                    // Опускаем флаг
      }

      if (FlagEfRand_Min == true && Flag_Each_Sigment == true) {  // Если поднят флаг генерации рандомного цвета (1 раз каждую минуту) и поднят флаг разноцветных сегментов и точек, то...
        Random_Color_Segment();                                   // Выполняем функцию рандомной генерации и установки разных цветов на всех сегментах
        FlagEfRand_Min = false;                                   // Опускаем флаг
      }
      break;  // Выходим из case
  }


  // ДЛЯ ОТЛАДКИ static uint32_t tmrPRs = 0;

  // if (millis() - tmrPRs >= 1000) {  // Проверяем раз в 1 сек
  //   tmrPRs = millis();              // Обнуляем таймер

  //   Serial.print("ledColor: ");
  //   Serial.println(ledColor);
  //   Serial.println();
  // }
}
